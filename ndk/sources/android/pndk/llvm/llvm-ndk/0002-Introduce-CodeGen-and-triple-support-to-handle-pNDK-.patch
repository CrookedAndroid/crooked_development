diff --git a/include/llvm/ADT/Triple.h b/include/llvm/ADT/Triple.h
index f5f99d0..1e98367 100644
--- a/include/llvm/ADT/Triple.h
+++ b/include/llvm/ADT/Triple.h
@@ -98,6 +98,7 @@ public:
     Minix,
     RTEMS,
     NativeClient,
+    NDK,        // Android NDK
     CNK         // BG/P Compute-Node Kernel
   };
   enum EnvironmentType {
diff --git a/lib/Support/Triple.cpp b/lib/Support/Triple.cpp
index 44a1b38..72dce03 100644
--- a/lib/Support/Triple.cpp
+++ b/lib/Support/Triple.cpp
@@ -118,6 +118,7 @@ const char *Triple::getOSTypeName(OSType Kind) {
   case Minix: return "minix";
   case RTEMS: return "rtems";
   case NativeClient: return "nacl";
+  case NDK: return "ndk";
   case CNK: return "cnk";
   }
 
@@ -287,6 +288,7 @@ static Triple::OSType parseOS(StringRef OSName) {
     .StartsWith("minix", Triple::Minix)
     .StartsWith("rtems", Triple::RTEMS)
     .StartsWith("nacl", Triple::NativeClient)
+    .StartsWith("ndk", Triple::NDK)
     .StartsWith("cnk", Triple::CNK)
     .Default(Triple::UnknownOS);
 }
diff --git a/tools/clang/lib/Basic/Targets.cpp b/tools/clang/lib/Basic/Targets.cpp
index dd2a89a..8441c38 100644
--- a/tools/clang/lib/Basic/Targets.cpp
+++ b/tools/clang/lib/Basic/Targets.cpp
@@ -3899,6 +3899,74 @@ void PNaClTargetInfo::getGCCRegAliases(const GCCRegAlias *&Aliases,
 } // end anonymous namespace.
 
 
+namespace {
+
+class AndroidNdkTargetInfo : public TargetInfo {
+public:
+  AndroidNdkTargetInfo(const std::string& TripleStr);
+
+  virtual void getTargetDefines(const LangOptions& Opts,
+                                MacroBuilder& Builder) const;
+
+  virtual const char* getVAListDeclaration() const {
+    return "typedef void* __builtin_va_list;";
+  }
+
+  virtual void getTargetBuiltins(const Builtin::Info*& Records,
+                                 unsigned& NumRecords) const {
+  }
+
+  virtual const char* getClobbers() const {
+    return "";
+  }
+
+  virtual void getGCCRegNames(const char* const*& Names,
+                              unsigned& NumNames) const {
+    Names = NULL;
+    NumNames = 0;
+  }
+
+  virtual void getGCCRegAliases(const TargetInfo::GCCRegAlias*& Aliases,
+                                unsigned& NumAliases) const {
+    Aliases = NULL;
+    NumAliases = 0;
+  }
+
+  virtual bool validateAsmConstraint(const char*& Name,
+                                     TargetInfo::ConstraintInfo& Info) const {
+    return false;
+  }
+};
+
+AndroidNdkTargetInfo::AndroidNdkTargetInfo(const std::string& Triple)
+    : TargetInfo(Triple) {
+  BigEndian = false;
+  NoAsmVariants = true;
+
+  DoubleAlign = LongLongAlign = LongDoubleAlign = SuitableAlign = 64;
+
+  SizeType = UnsignedInt;
+  PtrDiffType = SignedInt;
+  IntPtrType = SignedInt;
+
+  MaxAtomicPromoteWidth = MaxAtomicInlineWidth = 64;
+  RegParmMax = 3;
+  CXXABI = clang::CXXABI_ARM;
+  UseZeroLengthBitfieldAlignment = true;
+
+  DescriptionString = "e-p:32:32:32-i1:8:8-i8:8:8-i16:16:16-i32:32:32-"
+                      "i64:32:64-f32:32:32-f64:32:64-v64:64:64-"
+                      "v128:64:128-a0:0:64-n32-S64";
+}
+
+void AndroidNdkTargetInfo::getTargetDefines(const LangOptions& Opts,
+                                         MacroBuilder& Builder) const {
+  Builder.defineMacro("__ANDROID__");
+  Builder.defineMacro("__ELF__");
+}
+
+} // end anonymous namespace
+
 //===----------------------------------------------------------------------===//
 // Driver code
 //===----------------------------------------------------------------------===//
@@ -3995,6 +4063,8 @@ static TargetInfo *AllocateTarget(const std::string &T) {
     switch (os) {
       case llvm::Triple::NativeClient:
         return new PNaClTargetInfo(T);
+      case llvm::Triple::NDK:
+        return new AndroidNdkTargetInfo(T);
       default:
         return NULL;
     }
diff --git a/tools/clang/lib/CodeGen/TargetInfo.cpp b/tools/clang/lib/CodeGen/TargetInfo.cpp
index 2b71fdd..aabb8eb 100644
--- a/tools/clang/lib/CodeGen/TargetInfo.cpp
+++ b/tools/clang/lib/CodeGen/TargetInfo.cpp
@@ -3602,6 +3602,103 @@ llvm::Value *HexagonABIInfo::EmitVAArg(llvm::Value *VAListAddr, QualType Ty,
 }
 
 
+//===----------------------------------------------------------------------===//
+// Android ABI Implementation
+//===----------------------------------------------------------------------===//
+namespace {
+
+class AndroidABIInfo : public ABIInfo {
+public:
+  AndroidABIInfo(CodeGenTypes &CGT) : ABIInfo(CGT) {}
+
+private:
+  ABIArgInfo classifyReturnType(QualType RetTy) const;
+  ABIArgInfo classifyArgumentType(QualType RetTy) const;
+
+  virtual void computeInfo(CGFunctionInfo &FI) const;
+
+  virtual llvm::Value *EmitVAArg(llvm::Value *VAListAddr, QualType Ty,
+                                 CodeGenFunction &CGF) const;
+};
+
+class AndroidTargetCodeGenInfo : public TargetCodeGenInfo {
+public:
+  AndroidTargetCodeGenInfo(CodeGenTypes &CGT)
+    : TargetCodeGenInfo(new AndroidABIInfo(CGT)) {}
+};
+
+}
+
+ABIArgInfo AndroidABIInfo::classifyArgumentType(QualType Ty) const {
+  if (!isAggregateTypeForABI(Ty)) {
+    // Treat an enum type as its underlying type.
+    if (const EnumType *EnumTy = Ty->getAs<EnumType>())
+      Ty = EnumTy->getDecl()->getIntegerType();
+
+    return (Ty->isPromotableIntegerType() ?
+            ABIArgInfo::getExtend() : ABIArgInfo::getDirect());
+  }
+
+  // Ignore empty records.
+  if (isEmptyRecord(getContext(), Ty, true))
+    return ABIArgInfo::getIgnore();
+
+  // Structures with either a non-trivial destructor or a non-trivial
+  // copy constructor are always indirect.
+  if (isRecordWithNonTrivialDestructorOrCopyConstructor(Ty))
+    return ABIArgInfo::getIndirect(0, /*ByVal=*/false);
+
+  // Otherwise, pass by coercing to a structure of the appropriate size.
+  llvm::Type* ElemTy;
+  unsigned SizeRegs;
+  if (getContext().getTypeAlign(Ty) > 32) {
+    ElemTy = llvm::Type::getInt64Ty(getVMContext());
+    SizeRegs = (getContext().getTypeSize(Ty) + 63) / 64;
+  } else {
+    ElemTy = llvm::Type::getInt32Ty(getVMContext());
+    SizeRegs = (getContext().getTypeSize(Ty) + 31) / 32;
+  }
+
+  llvm::Type *STy =
+    llvm::StructType::get(llvm::ArrayType::get(ElemTy, SizeRegs), NULL);
+  return ABIArgInfo::getDirect(STy);
+}
+
+ABIArgInfo AndroidABIInfo::classifyReturnType(QualType RetTy) const {
+  if (RetTy->isVoidType())
+    return ABIArgInfo::getIgnore();
+
+  if (isAggregateTypeForABI(RetTy))
+    return ABIArgInfo::getIndirect(0);
+
+  // Treat an enum type as its underlying type.
+  if (const EnumType *EnumTy = RetTy->getAs<EnumType>())
+    RetTy = EnumTy->getDecl()->getIntegerType();
+
+  return (RetTy->isPromotableIntegerType() ?
+          ABIArgInfo::getExtend() : ABIArgInfo::getDirect());
+}
+
+void AndroidABIInfo::computeInfo(CGFunctionInfo &FI) const {
+    FI.getReturnInfo() = classifyReturnType(FI.getReturnType());
+    for (CGFunctionInfo::arg_iterator it = FI.arg_begin(), ie = FI.arg_end();
+         it != ie; ++it)
+      it->info = classifyArgumentType(it->type);
+}
+
+llvm::Value *AndroidABIInfo::EmitVAArg(llvm::Value *VAListAddr, QualType Ty,
+                                       CodeGenFunction &CGF) const {
+  CGBuilderTy &Builder = CGF.Builder;
+  llvm::Type *PTy =
+    llvm::PointerType::getUnqual(CGF.ConvertType(Ty));
+
+  // Since ABIInfo::EmitVAArg should return a pointer of Ty,
+  // We emit va_arg i8** va_list, Ty* for Ty
+  llvm::Value *v = Builder.CreateVAArg(VAListAddr, PTy);
+  return v;
+}
+
+
 const TargetCodeGenInfo &CodeGenModule::getTargetCodeGenInfo() {
   if (TheTargetCodeGenInfo)
     return *TheTargetCodeGenInfo;
@@ -3694,5 +3791,11 @@ const TargetCodeGenInfo &CodeGenModule::getTargetCodeGenInfo() {
   }
   case llvm::Triple::hexagon:
     return *(TheTargetCodeGenInfo = new HexagonTargetCodeGenInfo(Types));
+
+  case llvm::Triple::le32: {
+    if (Triple.getOS() == llvm::Triple::NDK) {
+      return *(TheTargetCodeGenInfo = new AndroidTargetCodeGenInfo(Types));
+    }
+  }
   }
 }
diff --git a/tools/clang/lib/Driver/Driver.cpp b/tools/clang/lib/Driver/Driver.cpp
index 3ddac69..ecc3505 100644
--- a/tools/clang/lib/Driver/Driver.cpp
+++ b/tools/clang/lib/Driver/Driver.cpp
@@ -1740,6 +1740,12 @@ bool Driver::ShouldUseClangCompiler(const Compilation &C, const JobAction &JA,
       types::isOnlyAcceptedByClang(JA.getType()))
     return true;
 
+  // For Android pNDK usage
+  if (Triple.getArch() == llvm::Triple::le32 &&
+      Triple.getOS() == llvm::Triple::NDK) {
+    return true;
+  }
+
   // Finally, don't use clang if this isn't one of the user specified archs to
   // build.
   if (!CCCClangArchs.empty() && !CCCClangArchs.count(Triple.getArch())) {
-- 
1.7.0.4

